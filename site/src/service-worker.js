// Conditionally compile the service worker cache based on the
// _HAS_SERVICE_WORKER_CACHE feature flag. See below for more details.
//#if _HAS_SERVICE_WORKER_CACHE
import { timestamp, files, shell } from '@sapper/service-worker';
//#else
import { timestamp } from '@sapper/service-worker';
//#endif

const ASSETS = `cache${timestamp}`;

//#if _HAS_SERVICE_WORKER_CACHE
// Exclude images, documents, and configuration files from the service worker; we don't want to download the entire
// site to the user's device; it's a waste of bandwidth and storage.
const fileExclusions = ["^\\/CNAME$", ".*\\.(jpg|jpeg|png|pdf)(\\?.*)?$"];

// `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory,
// `filteredFiles` is an array of files absent those matching any of the `fileExclusions` regexps.
const filteredFiles = files.filter(file =>
    !fileExclusions.some(exclusion => new RegExp(exclusion, "i").test(file))
);
const to_cache = shell.concat(filteredFiles);
const cached = new Set(to_cache);
//#endif

self.addEventListener('install', event => {
    event.waitUntil((async () => {
        //#if _HAS_SERVICE_WORKER_CACHE
        const cache = await caches.open(ASSETS);
        await cache.addAll(to_cache);
        //#endif
        self.skipWaiting();
    })());
});

self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(async keys => {
            // Delete old caches
            for (const key of keys) {
                if (key !== ASSETS) {
                    await caches.delete(key);
                }
            }

            self.clients.claim();
        })
    );
});

// Incapacitate the service worker if the _HAS_SERVICE_WORKER_CACHE feature flag
// is falsey. The `install` and `activate` listener remain to tidy up if
// necessary.
//#if _HAS_SERVICE_WORKER_CACHE
self.addEventListener('fetch', event => {
    if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

    const url = new URL(event.request.url);

    // Don't try to handle e.g. data: URIs
    if (!url.protocol.startsWith('http')) return;

    // Ignore dev server requests
    if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

    // Always serve static files and bundler-generated assets from cache
    if (url.host === self.location.host && cached.has(url.pathname)) {
        event.respondWith(caches.match(event.request));
        return;
    }

    if (event.request.cache === 'only-if-cached') return;

    // For everything else, try the cache first, falling back to network
    event.respondWith(
        caches
            .open(`offline${timestamp}`)
            .then(async cache => {
                let response = await cache.match(event.request);
                if (response) {
                    return response;
                }

                response = await fetch(event.request);
                cache.put(event.request, response.clone());
                return response;
            })
    );
});
//#endif
